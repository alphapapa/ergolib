(require :iterators)(require :cl-ppcre)(defv $variable-prefix-character #\$)(define-class variable name type)(define-print-method (variable name type) "$~A<~A>" name type)(defv $vaariable-regex (strcat "^\\" $variable-prefix-character "(.*?)(?:<(.*)>)?$"))(defun maybe-parse-var (var)  (and (symbolp var)       (aif (nth-value 1 (ppcre::scan-to-strings $vaariable-regex (symbol-name var)))         (make-variable :name (intern (elt it 0)) :type (aif (elt it 1) (intern it) t)))))(defun fail (&optional (value :fail)) (throw :fail value))(defun pm-loop (e1 e2 bindings)  (mcond   (maybe-parse-var e1) (pm-var-unify it e2 bindings)   (equal e1 e2) bindings   (or (atom e1) (atom e2)) (fail)   t (pm-loop (rst e1) (rst e2) (pm-loop (fst e1) (fst e2) bindings))))(define-method (pm-var-unify (var variable name type) expr bindings)  (aif (assoc name bindings)    (if (equal (rst it) expr)      bindings      (fail))    (if (typep expr (variable-type var))      (acons name expr bindings)      (fail))))(defun collect-variables (pattern)  (bb result nil      (for v in (leaves pattern) do        (aif (maybe-parse-var v)          (pushnew it result :key 'variable-name)))      result))(defmacro pm-if (value pattern then else)  (with-gensyms (bindings)    `(bb ,bindings (catch :fail (pm-loop ',pattern ,value nil))         (if (listp ,bindings)           (let ,(for v in (collect-variables pattern) collect                   (list (variable-name v) `(cdr (assoc ',(variable-name v) ,bindings))))             ,then)           ,else))))(defmacro pm-cond (value &rest clauses)  (mcond   (null clauses) nil   (null (rst clauses)) (1st clauses)   (not (symbolp value)) (with-gensyms (v) `(bb ,v ,value (pm-cond ,v ,@clauses)))   t `(pm-if ,value ,(1st clauses) ,(2nd clauses)             (pm-cond ,value ,@(rrst clauses)))))(defindent "pm-cond" 1)(defmacro defpm (name &rest clauses)  (with-gensyms (args)    `(defun ,name (,args) (pm-cond ,args ,@clauses))))(defindent "defpm" 1)#+NIL((defpm foo  ($x<integer>) (list 'integer x)  ($x<float>) (list 'float x)  ($x $x $x) (list 'three-of x)  ($x $y $x) (list 'palindrome x y)  ($x b $y) (list x y)  $x (list 'other x))(foo '(1))(foo '(1.2))(foo '(a a a))(foo '(a b a))(foo '(a b c))(foo '(x y z))(defpm baz  ($x<month>) (list 'month x)  ($x<weekday>) (list 'weekday x)  ($x) (list 'other x))(baz 'jan)(baz 'fri)(baz 'foo))